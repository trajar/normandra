/*
 * Apache License
 * Version 2.0, January 2004
 * http://www.apache.org/licenses/
 *
 * TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 *
 * 1. Definitions.
 *
 * "License" shall mean the terms and conditions for use, reproduction, and
 * distribution as defined by Sections 1 through 9 of this document.
 *
 * "Licensor" shall mean the copyright owner or entity authorized by the copyright
 * owner that is granting the License.
 *
 * "Legal Entity" shall mean the union of the acting entity and all other entities
 * that control, are controlled by, or are under common control with that entity.
 * For the purposes of this definition, "control" means (i) the power, direct or
 * indirect, to cause the direction or management of such entity, whether by
 * contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the
 * outstanding shares, or (iii) beneficial ownership of such entity.
 *
 * "You" (or "Your") shall mean an individual or Legal Entity exercising
 * permissions granted by this License.
 *
 * "Source" form shall mean the preferred form for making modifications, including
 * but not limited to software tagSource code, documentation tagSource, and configuration
 * files.
 *
 * "Object" form shall mean any form resulting from mechanical transformation or
 * translation of a Source form, including but not limited to compiled object code,
 * generated documentation, and conversions to other media types.
 *
 * "Work" shall mean the work of authorship, whether in Source or Object form, made
 * available under the License, as indicated by a copyright notice that is included
 * in or attached to the work (an example is provided in the Appendix below).
 *
 * "Derivative Works" shall mean any work, whether in Source or Object form, that
 * is based on (or derived from) the Work and for which the editorial revisions,
 * annotations, elaborations, or other modifications represent, as a whole, an
 * original work of authorship. For the purposes of this License, Derivative Works
 * shall not include works that remain separable from, or merely link (or bind by
 * name) to the interfaces of, the Work and Derivative Works thereof.
 *
 * "Contribution" shall mean any work of authorship, including the original version
 * of the Work and any modifications or additions to that Work or Derivative Works
 * thereof, that is intentionally submitted to Licensor for inclusion in the Work
 * by the copyright owner or by an individual or Legal Entity authorized to submit
 * on behalf of the copyright owner. For the purposes of this definition,
 * "submitted" means any form of electronic, verbal, or written communication sent
 * to the Licensor or its representatives, including but not limited to
 * communication on electronic mailing lists, tagSource code control systems, and
 * issue tracking systems that are managed by, or on behalf of, the Licensor for
 * the purpose of discussing and improving the Work, but excluding communication
 * that is conspicuously marked or otherwise designated in writing by the copyright
 * owner as "Not a Contribution."
 *
 * "Contributor" shall mean Licensor and any individual or Legal Entity on behalf
 * of whom a Contribution has been received by Licensor and subsequently
 * incorporated within the Work.
 *
 * 2. Grant of Copyright License.
 *
 * Subject to the terms and conditions of this License, each Contributor hereby
 * grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free,
 * irrevocable copyright license to reproduce, prepare Derivative Works of,
 * publicly display, publicly perform, sublicense, and distribute the Work and such
 * Derivative Works in Source or Object form.
 *
 * 3. Grant of Patent License.
 *
 * Subject to the terms and conditions of this License, each Contributor hereby
 * grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free,
 * irrevocable (except as stated in this section) patent license to make, have
 * made, use, offer to sell, sell, import, and otherwise transfer the Work, where
 * such license applies only to those patent claims licensable by such Contributor
 * that are necessarily infringed by their Contribution(s) alone or by combination
 * of their Contribution(s) with the Work to which such Contribution(s) was
 * submitted. If You institute patent litigation against any entity (including a
 * cross-claim or counterclaim in a lawsuit) alleging that the Work or a
 * Contribution incorporated within the Work constitutes direct or contributory
 * patent infringement, then any patent licenses granted to You under this License
 * for that Work shall terminate as of the date such litigation is filed.
 *
 * 4. Redistribution.
 *
 * You may reproduce and distribute copies of the Work or Derivative Works thereof
 * in any medium, with or without modifications, and in Source or Object form,
 * provided that You meet the following conditions:
 *
 * You must give any other recipients of the Work or Derivative Works a copy of
 * this License; and
 * You must cause any modified files to carry prominent notices stating that You
 * changed the files; and
 * You must retain, in the Source form of any Derivative Works that You distribute,
 * all copyright, patent, trademark, and attribution notices from the Source form
 * of the Work, excluding those notices that do not pertain to any part of the
 * Derivative Works; and
 * If the Work includes a "NOTICE" text file as part of its distribution, then any
 * Derivative Works that You distribute must include a readable copy of the
 * attribution notices contained within such NOTICE file, excluding those notices
 * that do not pertain to any part of the Derivative Works, in at least one of the
 * following places: within a NOTICE text file distributed as part of the
 * Derivative Works; within the Source form or documentation, if provided along
 * with the Derivative Works; or, within a display generated by the Derivative
 * Works, if and wherever such third-party notices normally appear. The contents of
 * the NOTICE file are for informational purposes only and do not modify the
 * License. You may add Your own attribution notices within Derivative Works that
 * You distribute, alongside or as an addendum to the NOTICE text from the Work,
 * provided that such additional attribution notices cannot be construed as
 * modifying the License.
 * You may add Your own copyright statement to Your modifications and may provide
 * additional or different license terms and conditions for use, reproduction, or
 * distribution of Your modifications, or for any such Derivative Works as a whole,
 * provided Your use, reproduction, and distribution of the Work otherwise complies
 * with the conditions stated in this License.
 *
 * 5. Submission of Contributions.
 *
 * Unless You explicitly state otherwise, any Contribution intentionally submitted
 * for inclusion in the Work by You to the Licensor shall be under the terms and
 * conditions of this License, without any additional terms or conditions.
 * Notwithstanding the above, nothing herein shall supersede or modify the terms of
 * any separate license agreement you may have executed with Licensor regarding
 * such Contributions.
 *
 * 6. Trademarks.
 *
 * This License does not grant permission to use the trade names, trademarks,
 * service marks, or product names of the Licensor, except as required for
 * reasonable and customary use in describing the origin of the Work and
 * reproducing the content of the NOTICE file.
 *
 * 7. Disclaimer of Warranty.
 *
 * Unless required by applicable law or agreed to in writing, Licensor provides the
 * Work (and each Contributor provides its Contributions) on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied,
 * including, without limitation, any warranties or conditions of TITLE,
 * NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are
 * solely responsible for determining the appropriateness of using or
 * redistributing the Work and assume any risks associated with Your exercise of
 * permissions under this License.
 *
 * 8. Limitation of Liability.
 *
 * In no event and under no legal theory, whether in tort (including negligence),
 * contract, or otherwise, unless required by applicable law (such as deliberate
 * and grossly negligent acts) or agreed to in writing, shall any Contributor be
 * liable to You for damages, including any direct, indirect, special, incidental,
 * or consequential damages of any character arising as a result of this License or
 * out of the use or inability to use the Work (including but not limited to
 * damages for loss of goodwill, work stoppage, computer failure or malfunction, or
 * any and all other commercial damages or losses), even if such Contributor has
 * been advised of the possibility of such damages.
 *
 * 9. Accepting Warranty or Additional Liability.
 *
 * While redistributing the Work or Derivative Works thereof, You may choose to
 * offer, and charge a fee for, acceptance of support, warranty, indemnity, or
 * other liability obligations and/or rights consistent with this License. However,
 * in accepting such obligations, You may act only on Your own behalf and on Your
 * sole responsibility, not on behalf of any other Contributor, and only if You
 * agree to indemnify, defend, and hold each Contributor harmless for any liability
 * incurred by, or claims asserted against, such Contributor by reason of your
 * accepting any such warranty or additional liability.
 *
 * END OF TERMS AND CONDITIONS
 *
 * APPENDIX: How to apply the Apache License to your work
 *
 * To apply the Apache License to your work, attach the following boilerplate
 * notice, with the fields enclosed by brackets "[]" replaced with your own
 * identifying information. (Don't include the brackets!) The text should be
 * enclosed in the appropriate comment syntax for the file format. We also
 * recommend that a file or class name and description of purpose be included on
 * the same "printed page" as the copyright notice for easier identification within
 * third-party archives.
 *
 *    Copyright [yyyy] [name of copyright owner]
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package org.normandra.meta;

import com.fasterxml.jackson.annotation.JsonProperty;
import org.apache.commons.lang.NullArgumentException;
import org.normandra.data.BasicIdAccessor;
import org.normandra.data.ColumnAccessor;
import org.normandra.data.ColumnAccessorFactory;
import org.normandra.data.CompositeIdAccessor;
import org.normandra.data.ListColumnAccessor;
import org.normandra.data.NestedColumnAccessor;
import org.normandra.data.NullIdAccessor;
import org.normandra.data.ReadOnlyColumnAccessor;
import org.normandra.data.SetColumnAccessor;
import org.normandra.util.ArraySet;
import org.normandra.util.CaseUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.persistence.Column;
import javax.persistence.DiscriminatorColumn;
import javax.persistence.DiscriminatorValue;
import javax.persistence.ElementCollection;
import javax.persistence.Embeddable;
import javax.persistence.EmbeddedId;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.Index;
import javax.persistence.Inheritance;
import javax.persistence.InheritanceType;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.ManyToMany;
import javax.persistence.ManyToOne;
import javax.persistence.NamedQueries;
import javax.persistence.NamedQuery;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.Table;
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.math.BigInteger;
import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.stream.Collectors;

/**
 * a class used to parse jpa annotations
 * <p>
 * <p>
 * Date: 9/1/13
 */
public class AnnotationParser
{
    private static final Logger logger = LoggerFactory.getLogger(AnnotationParser.class);

    private final SecureRandom random = new SecureRandom();

    private final List<Class> classes;

    private final ColumnAccessorFactory factory;

    private final Map<Class, EntityMeta> entities = new LinkedHashMap<>();

    private final Map<String, TableMeta> tables = new TreeMap<>();

    public AnnotationParser(final ColumnAccessorFactory factory, final Class clazz, final Class... list)
    {
        if (null == factory)
        {
            throw new NullArgumentException("factory");
        }
        if (null == clazz)
        {
            throw new NullArgumentException("class");
        }
        this.factory = factory;
        this.classes = new ArrayList<>();
        this.classes.add(clazz);
        if (list != null && list.length > 0)
        {
            for (final Class<?> item : list)
            {
                if (item != null)
                {
                    this.classes.add(item);
                }
            }
        }
    }

    public AnnotationParser(final ColumnAccessorFactory factory, final Collection<Class> c)
    {
        if (null == factory)
        {
            throw new NullArgumentException("factory");
        }
        if (null == c)
        {
            throw new NullArgumentException("classes");
        }
        this.factory = factory;
        this.classes = new ArrayList<>(c);
    }

    public Set<EntityMeta> read()
    {
        // read first pass for all entities
        for (final Class<?> clazz : this.classes)
        {
            this.readEntity(clazz);
        }

        // ensure we read second pass
        final Set<EntityMeta> set = new TreeSet<>(this.entities.values());
        for (final EntityMeta entity : set)
        {
            this.readSecondPass(entity);
        }

        // read indexed columns
        for (final EntityMeta entity : set)
        {
            for (final IndexMeta index : this.readIndices(entity))
            {
                entity.addIndexed(index);
            }
        }

        // done
        return Collections.unmodifiableSet(set);
    }

    private Collection<IndexMeta> readIndices(final EntityMeta entity)
    {
        final List<Index> annotations = new ArrayList<>();
        for (final Table table : this.findAnnotations(entity.getType(), Table.class))
        {
            if (table.indexes().length > 0)
            {
                annotations.addAll(Arrays.asList(table.indexes()));
            }
        }
        annotations.addAll(this.findAnnotations(entity.getType(), Index.class));

        final List<IndexMeta> indices = new ArrayList<>();
        for (final Index annotation : annotations)
        {
            final Set<String> columnNames = new ArraySet<>(annotations.size());
            for (final String columnName : annotation.columnList().split(",|;|\\s+"))
            {
                final String trimmed = columnName.trim();
                if (!trimmed.isEmpty())
                {
                    columnNames.add(trimmed);
                }
            }
            final List<ColumnMeta> columns = columnNames.stream()
                .map(entity::findColumn)
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
            if (!columns.isEmpty())
            {
                String defaultName = annotation.name();
                if (defaultName.trim().isEmpty())
                {
                    if (columns.size() == 1)
                    {
                        defaultName = columns.get(0).getName();
                    }
                    else
                    {
                        defaultName = "index_" + new BigInteger(64, random).toString(32).toLowerCase();
                    }
                }
                indices.add(new IndexMeta(defaultName, columns, annotation.unique()));
            }
        }
        return Collections.unmodifiableCollection(indices);
    }

    private TableMeta readTable(final EntityMeta entity, final String tableName)
    {
        if (null == entity)
        {
            return null;
        }
        TableMeta table = this.tables.get(tableName);
        if (null == table)
        {
            table = new TableMeta(tableName, false);
            this.tables.put(tableName, table);
        }
        if (entity.getTable(tableName) == null)
        {
            entity.addTable(table);
        }
        return table;
    }

    private <T> EntityContext readContext(final Class<T> entityClass)
    {
        if (this.classes.contains(entityClass))
        {
            // this clazz is an entity class
            final EntityMeta entity = this.readEntity(entityClass);
            if (null == entity)
            {
                return null;
            }
            return new SingleEntityContext(entity);
        }
        else
        {
            final List<EntityMeta> metas = new ArrayList<>();
            for (final Class<?> clazz : this.classes)
            {
                if (entityClass.isAssignableFrom(clazz))
                {
                    final EntityMeta entity = this.readEntity(clazz);
                    if (entity != null)
                    {
                        metas.add(entity);
                    }
                }
            }
            if (metas.isEmpty())
            {
                return null;
            }
            else if (metas.size() == 1)
            {
                return new SingleEntityContext(metas.get(0));
            }
            else
            {
                return new HierarchyEntityContext(metas);
            }
        }
    }

    private <T> EntityMeta readEntity(final Class<T> entityClass)
    {
        if (!this.classes.contains(entityClass))
        {
            return null;
        }

        final EntityMeta existing = this.entities.get(entityClass);
        if (existing != null)
        {
            return existing;
        }

        boolean entity = false;
        for (final Class<?> clazz : this.getHierarchy(entityClass))
        {
            if (clazz.getAnnotation(Entity.class) != null)
            {
                entity = true;
                break;
            }
        }
        if (!entity)
        {
            return null;
        }

        // create entity first - to help resolve cyclical relationships
        final String name = this.getEntity(entityClass);
        final EntityMeta meta = new EntityMeta(name, entityClass);
        this.entities.put(entityClass, meta);

        // configure entity
        this.readFirstPass(meta);
        this.readIdAccessor(meta);

        // done
        return meta;
    }

    public boolean isEntity(final Class<?> entityClass)
    {
        return this.readEntity(entityClass) != null;
    }

    protected String getEntity(final Class<?> entityClass)
    {
        final Entity entity = entityClass.getAnnotation(Entity.class);
        if (null == entity)
        {
            return null;
        }
        final String name = entity.name();
        if (!name.isEmpty())
        {
            return name;
        }
        return entityClass.getSimpleName();
    }

    protected String getTable(final EntityMeta entity, final Class<?> clazz)
    {
        // get default table name for entity
        String tableName = CaseUtils.camelToSnakeCase(entity.getType().getSimpleName());
        for (final Class<?> hierarchyClass : this.getHierarchy(entity.getType()))
        {
            final Table table = hierarchyClass.getAnnotation(Table.class);
            if (table != null)
            {
                tableName = table.name();
                break;
            }
        }
        if (clazz.equals(entity.getType()))
        {
            return tableName;
        }

        // first determine if we have an inherited entity split across a table
        final Inheritance inheritance = this.findAnnotation(entity.getClass(), Inheritance.class);
        if (null == inheritance || !InheritanceType.JOINED.equals(inheritance.strategy()))
        {
            return tableName;
        }

        // determine if we are looking at base table
        String baseName = tableName;
        for (final Class<?> hierarchyClass : this.getHierarchy(entity.getType()))
        {
            final Table table = hierarchyClass.getAnnotation(Table.class);
            if (table != null)
            {
                baseName = table.name();
            }
            if (hierarchyClass.equals(clazz))
            {
                return baseName;
            }
        }
        return baseName;
    }

    public Collection<QueryMeta> getQueries(final Class<?> entityClass)
    {
        final EntityContext context = this.readContext(entityClass);
        if (null == context)
        {
            return Collections.emptyList();
        }
        final Set<QueryMeta> result = new TreeSet<>();
        for (final Class<?> clazz : this.getHierarchy(entityClass))
        {
            final List<NamedQuery> annotations = new ArrayList<>();
            final NamedQueries queries = clazz.getAnnotation(NamedQueries.class);
            if (queries != null)
            {
                annotations.addAll(Arrays.asList(queries.value()));
            }
            final NamedQuery query = clazz.getAnnotation(NamedQuery.class);
            if (query != null)
            {
                annotations.add(query);
            }
            for (final NamedQuery annotation : annotations)
            {
                result.add(new QueryMeta(clazz, annotation.name(), annotation.query()));
            }
        }
        return Collections.unmodifiableCollection(result);
    }

    public Map<Field, GeneratedValue> getGenerators(final Class<?> entityClass)
    {
        final Map<Field, GeneratedValue> map = new LinkedHashMap<>();
        for (final Class<?> clazz : this.getHierarchy(entityClass))
        {
            for (final Field field : this.getFields(clazz))
            {
                final GeneratedValue annotation = field.getAnnotation(GeneratedValue.class);
                if (annotation != null)
                {
                    map.put(field, annotation);
                }
            }
        }
        return Collections.unmodifiableMap(map);
    }

    public <T extends Annotation> T findAnnotation(final Class<?> entityClass, final Class<T> clazz)
    {
        final List<T> list = this.findAnnotations(entityClass, clazz);
        if (null == list || list.isEmpty())
        {
            return null;
        }
        return list.get(0);
    }

    public <T extends Annotation> List<T> findAnnotations(final Class<?> entityClass, final Class<T> clazz)
    {
        final List<T> list = new ArrayList<>();
        for (final Class<?> type : this.getHierarchy(entityClass))
        {
            final T classAnnotation = type.getAnnotation(clazz);
            if (classAnnotation != null)
            {
                list.add(classAnnotation);
            }
            for (final Field field : this.getFields(type, Collections.singleton(clazz)))
            {
                final T fieldAnnotation = field.getAnnotation(clazz);
                if (fieldAnnotation != null)
                {
                    list.add(fieldAnnotation);
                }
            }
        }
        return Collections.unmodifiableList(list);
    }

    /**
     * read secondary attributes, associations
     */
    private boolean readSecondPass(final EntityMeta entity)
    {
        if (null == entity)
        {
            return false;
        }

        // read secondary columns
        return this.readFields(entity, this.jpaAnnotations()) > 0;
    }

    /**
     * read core id / primary key attributes
     */
    private boolean readFirstPass(final EntityMeta entity)
    {
        if (null == entity)
        {
            return false;
        }

        // read all id columns
        final List<Class<? extends Annotation>> list = new ArrayList<>(2);
        list.add(EmbeddedId.class);
        list.add(Id.class);
        this.readFields(entity, list);

        // read hierarchy type discriminator (if applicable)
        final Class<?> entityClazz = entity.getType();
        final ColumnMeta discriminatorColumn = this.getDiscriminatorColumn(entityClazz);
        if (discriminatorColumn != null)
        {
            final DiscriminatorMeta discriminatorValue = this.getDiscriminatorValue(discriminatorColumn, entityClazz);
            if (discriminatorValue != null)
            {
                // find class that has table
                String tableName = this.getTable(entity, entityClazz);
                for (final Class<?> clazz : this.getHierarchy(entityClazz))
                {
                    final Inheritance inheritance = clazz.getAnnotation(Inheritance.class);
                    if (inheritance != null && !InheritanceType.TABLE_PER_CLASS.equals(inheritance.strategy()))
                    {
                        tableName = this.getTable(entity, clazz);
                        entity.setInherited(this.getEntity(clazz));
                        break;
                    }
                }
                final TableMeta table = this.readTable(entity, tableName);
                table.addColumn(discriminatorColumn);
                entity.setAccessor(discriminatorColumn, new ReadOnlyColumnAccessor(discriminatorValue.getValue()));
                entity.setDiscriminator(discriminatorValue);
            }
        }

        return true;
    }

    private int readFields(final EntityMeta entity, final Collection<Class<? extends Annotation>> annotations)
    {
        if (null == entity)
        {
            return 0;
        }

        int num = 0;
        for (final Class<?> clazz : this.getHierarchy(entity.getType()))
        {
            // ensure table exists
            final String tableName = this.getTable(entity, clazz);
            final TableMeta table = this.readTable(entity, tableName);

            // read fields
            for (final Field field : this.getFields(clazz, annotations))
            {
                if (this.configureField(entity, table, field))
                {
                    logger.debug("Configured metadata for [" + field + "] in [" + entity + "].");
                    num++;
                }
            }
        }
        return num;
    }

    private boolean readIdAccessor(final EntityMeta entity)
    {
        // find id fields
        final Class<?> entityClass = entity.getType();
        final List<Field> embeddedKeys = new ArrayList<>();
        final List<Field> regularKeys = new ArrayList<>();
        for (final Class<?> clazz : this.getHierarchy(entityClass))
        {
            for (final Field field : this.getFields(clazz))
            {
                if (field.getAnnotation(EmbeddedId.class) != null)
                {
                    embeddedKeys.add(field);
                }
                else if (field.getAnnotation(Id.class) != null)
                {
                    regularKeys.add(field);
                }
            }
        }

        if (embeddedKeys.isEmpty() && regularKeys.isEmpty())
        {
            return false;
        }
        if (!embeddedKeys.isEmpty() && !regularKeys.isEmpty())
        {
            throw new IllegalStateException("Cannot specify both @Id or @EmbeddedId annotations for class [" + entityClass + "].");
        }
        if (embeddedKeys.size() > 1 || regularKeys.size() > 1)
        {
            logger.warn("Multiple @Id or @EmbeddedId annotations found for class [" + entityClass + "] - you may be unable to access entity by #get api.");
            entity.setId(NullIdAccessor.getInstance());
            return true;
        }

        if (embeddedKeys.size() > 0)
        {
            // composite keys
            final Field key = embeddedKeys.get(0);
            final Map<ColumnMeta, ColumnAccessor> map = this.configureId(key, false);
            entity.setId(new CompositeIdAccessor(key, map));
            return true;
        }
        else if (regularKeys.size() > 0)
        {
            // regular primary key
            final Field key = regularKeys.get(0);
            final Collection<ColumnMeta> keyColumns = this.configureId(key, false).keySet();
            if (!keyColumns.isEmpty())
            {
                entity.setId(new BasicIdAccessor(key, keyColumns.iterator().next()));
                return true;
            }
        }

        // no id configured
        return false;
    }

    private String getColumnName(final Field field)
    {
        // basic column info
        final Column column = field.getAnnotation(Column.class);
        final JoinColumn join = field.getAnnotation(JoinColumn.class);
        String name = CaseUtils.camelToSnakeCase(field.getName());
        if (column != null && !column.name().trim().isEmpty())
        {
            name = column.name();
        }
        else if (join != null && !join.name().trim().isEmpty())
        {
            name = join.name();
        }
        return name;
    }

    private Map<ColumnMeta, ColumnAccessor> configureId(final Field field, final boolean useNested)
    {
        final Class<?> type = field.getType();
        final Id id = field.getAnnotation(Id.class);
        if (id != null)
        {
            final String name = this.getColumnName(field);
            final String property = field.getName();
            final ColumnMeta column = new ColumnMeta(name, property, type, true, false, false);
            final ColumnAccessor accessor = this.factory.createBasic(field, type);
            final Map<ColumnMeta, ColumnAccessor> map = new HashMap<>(1);
            map.put(column, accessor);
            return Collections.unmodifiableMap(map);
        }

        final EmbeddedId embeddedId = field.getAnnotation(EmbeddedId.class);
        if (embeddedId != null)
        {
            final Embeddable embeddable = type.getAnnotation(Embeddable.class);
            if (null == embeddable)
            {
                throw new IllegalStateException("Class [" + type + "] does not have Embeddable annotation.");
            }
            final Map<ColumnMeta, ColumnAccessor> map = new LinkedHashMap<>();
            for (final Field embeddedColumn : new AnnotationParser(this.factory, type).getFields(type))
            {
                final Class<?> embeddedClass = embeddedColumn.getType();
                final String embeddedName = this.getColumnName(embeddedColumn);
                final String property = field.getName() + "." + embeddedColumn.getName();
                final ColumnMeta column = new ColumnMeta(embeddedName, property, embeddedClass, true, false, false);
                final ColumnAccessor basic = this.factory.createBasic(embeddedColumn, embeddedClass);
                final ColumnAccessor accessor;
                if (useNested)
                {
                    accessor = new NestedColumnAccessor(field, basic);
                }
                else
                {
                    accessor = basic;
                }
                map.put(column, accessor);
            }
            return Collections.unmodifiableMap(map);
        }

        return Collections.emptyMap();
    }

    private boolean configureField(final EntityMeta entity, final TableMeta table, final Field field)
    {
        // basic column info
        final String name = this.getColumnName(field);
        final Class<?> type = field.getType();

        // primary key
        if (field.isAnnotationPresent(Id.class) || field.isAnnotationPresent(EmbeddedId.class))
        {
            return entity.putColumns(table, this.configureId(field, true));
        }

        // regular column
        if (field.isAnnotationPresent(ElementCollection.class))
        {
            return entity.putColumns(table, this.configureElementCollection(field, name, field.getName()));
        }

        // associations and join columns
        if (field.isAnnotationPresent(OneToOne.class))
        {
            return entity.putColumns(table, this.configureOneToOne(field, name, field.getName()));
        }
        else if (field.isAnnotationPresent(ManyToOne.class))
        {
            return entity.putColumns(table, this.configureManyToOne(field, name, field.getName()));
        }
        else if (field.isAnnotationPresent(OneToMany.class))
        {
            return this.configureOneToMany(entity, table, field, name, field.getName());
        }

        // regular column
        if (field.getAnnotation(Column.class) != null)
        {
            if (this.findAnnotations(type, Embeddable.class).isEmpty())
            {
                // basic column
                final boolean json = !this.findAnnotations(type, JsonProperty.class).isEmpty();
                final ColumnAccessor accessor = this.factory.createBasic(field, type);
                final ColumnMeta column = new ColumnMeta(name, field.getName(), type, false, false, json);
                final boolean modified = table.addColumn(column);
                entity.setAccessor(column, accessor);
                return modified;
            }
            else
            {
                // embeddable column
                boolean modified = false;
                for (final Field embeddedColumn : new AnnotationParser(this.factory, type).getFields(type))
                {
                    final Class<?> embeddedClass = embeddedColumn.getType();
                    final boolean json = !this.findAnnotations(embeddedClass, JsonProperty.class).isEmpty();
                    final String embeddedName = this.getColumnName(embeddedColumn);
                    final String property = field.getName() + "." + embeddedColumn.getName();
                    final ColumnMeta column = new ColumnMeta(embeddedName, property, embeddedClass, false, false, json);
                    final ColumnAccessor basic = this.factory.createBasic(embeddedColumn, embeddedClass);
                    final ColumnAccessor accessor = new NestedColumnAccessor(field, basic);
                    if (table.addColumn(column))
                    {
                        modified = true;
                        entity.setAccessor(column, accessor);
                    }
                }
                return modified;
            }
        }

        // unsupported column
        return false;
    }

    private Map<ColumnMeta, ColumnAccessor> configureOneToOne(final Field field, final String name, final String property)
    {
        final OneToOne oneToOne = field.getAnnotation(OneToOne.class);
        final boolean lazy = FetchType.LAZY.equals(oneToOne.fetch());
        final String mappedBy = oneToOne.mappedBy().trim();
        if (mappedBy.isEmpty())
        {
            // create table column for this relationship
            final Class<?> type = field.getType();
            final EntityContext entity = this.readContext(type);
            if (null == entity)
            {
                throw new IllegalStateException("Type [" + type + "] is not a registered entity.");
            }
            final ColumnAccessor accessor = this.factory.createSingleJoin(field, entity, lazy);
            final ColumnMeta primary = entity.getPrimaryKeys().iterator().next();
            final ColumnMeta column = new JoinColumnMeta(name, property, primary.getType(), entity, false);
            final Map<ColumnMeta, ColumnAccessor> map = new HashMap<>(1);
            map.put(column, accessor);
            return Collections.unmodifiableMap(map);
        }
        else
        {
            // this table does not own this column
            return Collections.emptyMap();
        }
    }

    private Map<ColumnMeta, ColumnAccessor> configureManyToOne(final Field field, final String name, final String property)
    {
        final ManyToOne manyToOne = field.getAnnotation(ManyToOne.class);
        final boolean lazy = FetchType.LAZY.equals(manyToOne.fetch());
        final Class<?> type = field.getType();
        final EntityContext entity = this.readContext(type);
        if (null == entity)
        {
            throw new IllegalStateException("Type [" + type + "] is not a registered entity.");
        }
        final ColumnAccessor accessor = this.factory.createSingleJoin(field, entity, lazy);
        final ColumnMeta primary = entity.getPrimaryKeys().iterator().next();
        final ColumnMeta column = new JoinColumnMeta(name, property, primary.getType(), entity, false);
        final Map<ColumnMeta, ColumnAccessor> map = new HashMap<>(1);
        map.put(column, accessor);
        return Collections.unmodifiableMap(map);
    }

    private boolean configureOneToMany(final EntityMeta parentEntity, final TableMeta table, final Field field, final String name, final String property)
    {
        // grab basic one-to-many parameters
        final OneToMany oneToMany = field.getAnnotation(OneToMany.class);
        final boolean lazy = FetchType.LAZY.equals(oneToMany.fetch());
        final Class<?> parameterizedClass;
        if (!void.class.equals(oneToMany.targetEntity()))
        {
            parameterizedClass = oneToMany.targetEntity();
        }
        else
        {
            final ParameterizedType parameterizedType = (ParameterizedType) field.getGenericType();
            final Type[] types = parameterizedType != null ? parameterizedType.getActualTypeArguments() : null;
            parameterizedClass = types != null && types.length > 0 ? (Class<?>) types[0] : null;
        }
        if (null == parameterizedClass)
        {
            return false;
        }

        final EntityContext associatedEntity = this.readContext(parameterizedClass);
        if (null == associatedEntity)
        {
            throw new IllegalStateException("Type [" + parameterizedClass + "] is not a registered entity.");
        }

        // determine if we are using a join table
        final JoinTable joinTable = field.getAnnotation(JoinTable.class);
        if (joinTable != null)
        {
            // we query the columns from a auxiliary join table
            final String tableName;
            if (joinTable.name().isEmpty())
            {
                tableName = CaseUtils.camelToSnakeCase(parentEntity.getName()) + "_" + CaseUtils.camelToSnakeCase(property);
            }
            else
            {
                tableName = joinTable.name();
            }
            TableMeta join = parentEntity.getTable(tableName);
            if (null == join)
            {
                join = new TableMeta(tableName, true);
                parentEntity.addTable(join);
            }
            for (final ColumnMeta primary : new SingleEntityContext(parentEntity).getPrimaryKeys())
            {
                join.addColumn(primary);
            }
            final ColumnMeta primary = associatedEntity.getPrimaryKey();
            final ColumnMeta column = new JoinCollectionMeta(name, property, primary.getType(), associatedEntity, true, lazy, false);
            final ColumnAccessor accessor = this.factory.createManyJoin(field, associatedEntity, lazy);
            join.addColumn(column);
            parentEntity.setAccessor(column, accessor);
            return true;
        }
        else if (!oneToMany.mappedBy().trim().isEmpty())
        {
            // we query this value via the other side of the relationship (which would require indices)
            for (final EntityMeta entity : associatedEntity.getEntities())
            {
                this.readSecondPass(entity);
            }

            // find the actual mapped column and table
            ColumnMeta mappedColumn = null;
            TableMeta mappedTable = null;
            for (final TableMeta associatedTable : associatedEntity.getTables())
            {
                mappedColumn = associatedTable.getColumn(oneToMany.mappedBy());
                if (mappedColumn != null)
                {
                    mappedTable = associatedTable;
                    break;
                }
            }
            if (null == mappedColumn)
            {
                throw new IllegalStateException("Unable to locate column [" + oneToMany.mappedBy() + "] within [" + associatedEntity + "].");
            }

            // setup column meta and accessor
            final ColumnAccessor accessor = this.factory.createManyJoin(field, associatedEntity, lazy);
            final ColumnMeta column = new MappedColumnMeta(associatedEntity, mappedTable, mappedColumn, name, property, field.getType(), lazy);
            table.addColumn(column);
            parentEntity.setAccessor(column, accessor);
            for (final EntityMeta entity : associatedEntity.getEntities())
            {
                entity.addIndexed(new IndexMeta(mappedColumn.getName(), Collections.singleton(mappedColumn), false));
            }
            return true;
        }
        else
        {
            // use embedded join-collection
            final ColumnAccessor accessor = this.factory.createManyJoin(field, associatedEntity, lazy);
            final ColumnMeta column = new JoinCollectionMeta(name, property, field.getType(), associatedEntity, false, lazy, true);
            table.addColumn(column);
            parentEntity.setAccessor(column, accessor);
            return true;
        }
    }

    private Map<ColumnMeta, ColumnAccessor> configureElementCollection(final Field field, final String name, final String property)
    {
        final ElementCollection annotation = field.getAnnotation(ElementCollection.class);
        final boolean lazy = annotation != null && FetchType.LAZY.equals(annotation.fetch());
        final Class<?> type = field.getType();
        final ParameterizedType parameterizedType = (ParameterizedType) field.getGenericType();
        final Type[] types = parameterizedType.getActualTypeArguments();
        final Class<?> parameterizedClass = types != null && types.length > 0 ? (Class<?>) types[0] : null;
        if (null == parameterizedClass)
        {
            return Collections.emptyMap();
        }

        if (this.isEntity(parameterizedClass))
        {
            return Collections.emptyMap();
        }

        final ColumnAccessor accessor;
        if (Set.class.isAssignableFrom(type))
        {
            accessor = new SetColumnAccessor(field, parameterizedClass, lazy);
        }
        else
        {
            accessor = new ListColumnAccessor(field, parameterizedClass, lazy);
        }
        final Map<ColumnMeta, ColumnAccessor> map = new HashMap<>(1);
        final boolean json = !this.findAnnotations(parameterizedClass, JsonProperty.class).isEmpty();
        final ColumnMeta column = new EmbeddedCollectionMeta(name, property, type, parameterizedClass, false, lazy, json);
        map.put(column, accessor);
        return Collections.unmodifiableMap(map);
    }

    private ColumnMeta getDiscriminatorColumn(final Class<?> entityClass)
    {
        DiscriminatorColumn column = null;
        for (final Class<?> clazz : this.getHierarchy(entityClass))
        {
            column = clazz.getAnnotation(DiscriminatorColumn.class);
            if (column != null)
            {
                break;
            }
        }
        if (null == column)
        {
            return null;
        }

        final String property = "DiscriminatorColumn";
        final String name = column.name();
        switch (column.discriminatorType())
        {
            case CHAR:
                return new ColumnMeta(name, property, Character.class, false, false, false);
            case INTEGER:
                return new ColumnMeta(name, property, Integer.class, false, false, false);
            case STRING:
            default:
                return new ColumnMeta(name, property, String.class, false, false, false);
        }
    }

    private DiscriminatorMeta getDiscriminatorValue(final ColumnMeta column, final Class<?> entityClass)
    {
        String discriminator = CaseUtils.camelToSnakeCase(entityClass.getSimpleName());
        for (final Class<?> clazz : this.getHierarchy(entityClass))
        {
            final DiscriminatorValue value = clazz.getAnnotation(DiscriminatorValue.class);
            if (value != null)
            {
                discriminator = value.value();
                break;
            }
        }

        if (null == column)
        {
            throw new IllegalArgumentException("Discriminator column cannot be null.");
        }
        final Class<?> type = column.getType();
        if (Character.class.equals(type))
        {
            return new DiscriminatorMeta(column, discriminator.charAt(0));
        }
        else if (Short.class.equals(type))
        {
            return new DiscriminatorMeta(column, Short.parseShort(discriminator));
        }
        else if (Integer.class.equals(type))
        {
            return new DiscriminatorMeta(column, Integer.parseInt(discriminator));
        }
        else if (Long.class.equals(type))
        {
            return new DiscriminatorMeta(column, Long.parseLong(discriminator));
        }
        else
        {
            return new DiscriminatorMeta(column, discriminator);
        }
    }

    private List<Field> getFields(final Class<?> clazz, final Collection<Class<? extends Annotation>> annotations)
    {
        if (null == clazz)
        {
            return Collections.emptyList();
        }

        final Field[] fields = clazz.getDeclaredFields();
        if (null == fields || fields.length <= 0)
        {
            return Collections.emptyList();
        }

        final List<Field> list = new ArrayList<>(fields.length);
        for (final Field field : fields)
        {
            if (!Modifier.isTransient(field.getModifiers()))
            {
                for (final Class<? extends Annotation> annotation : annotations)
                {
                    if (field.isAnnotationPresent(annotation))
                    {
                        list.add(field);
                    }
                }
            }
        }
        return list;
    }

    private List<Field> getFields(final Class<?> clazz)
    {
        return this.getFields(clazz, this.jpaAnnotations());
    }

    private Collection<Class<? extends Annotation>> jpaAnnotations()
    {
        final List<Class<? extends Annotation>> list = new ArrayList<>();
        list.add(Column.class);
        list.add(EmbeddedId.class);
        list.add(Id.class);
        list.add(ElementCollection.class);
        list.add(JoinColumn.class);
        list.add(OneToMany.class);
        list.add(ManyToOne.class);
        list.add(ManyToMany.class);
        list.add(OneToOne.class);
        return Collections.unmodifiableList(list);
    }

    private List<Class<?>> getHierarchy(final Class<?> entityClass)
    {
        if (null == entityClass || Object.class.equals(entityClass))
        {
            return Collections.emptyList();
        }
        final List<Class<?>> list = new ArrayList<>();
        list.add(entityClass);
        Class<?> parent = entityClass.getSuperclass();
        while (parent != null && !Object.class.equals(parent))
        {
            list.add(parent);
            parent = parent.getSuperclass();
        }
        return Collections.unmodifiableList(list);
    }
}
